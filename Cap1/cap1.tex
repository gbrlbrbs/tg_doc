\section{Motivation}
Often in a problem being tackled with Machine Learning techniques the most important part of the solving process is the algorithm selection. Each one has a specific bias which makes it more suitable for some classes of problems than others \cite{Lorena2022}. 

It is desirable, then, that we may have a way of measuring the relationship of the performance of a given algorithm in a problem with the problem's characteristics, since knowing which data is easy or difficult for a given model to classify is useful in the way that we may make changes to the original model and iterate it knowing what has been difficult in the past and if it has become more or less difficult in the new model.

In \cite{Munoz2018} we have been introduced to a novel way of performance evaluation in classifiers mapping the statistical properties of an instance (an entire dataset) into how difficult the instance is for the classification algorithm to perform. Further, in \cite{Lorena2022}, the methodology has been modified to have a more fine-grained analysis, with the instance being reduced to an individual observation.

Given this, we can map each observation into a hardness metric and have another variable that depends upon the observation. We may feed this data into a new model and get new information of the original model. One type of model that may give us new information is a Generative Adversarial Network (GAN) architecture as defined by \cite{Goodfellow2014}. Using this, we can create data with specific hardness metrics and set a difficulty of classification for an entire dataset.

\section{Objective}

This work's objective lies in providing a framework for data generation based on the relationship between instance hardness and classification performance using the GAN architecture. 

\section{Scope}

The scope of this work will be limited to exploring a GAN implementation for the generation of data, creating a Generator and a Discriminator.  The modeling will be made entirely using Python, with the PyTorch \cite{paszke2019pytorch} framework.

%\begin{figure}[ht]
%\centering
%\includegraphics[width=0.5\textwidth]{Cap1/cupim}
%\caption{Proibido estacionar cupins. Legenda grande, com o objetivo de demonstrar a indentação na lista de figuras.}
%\label{cupim}
%\end{figure}


%\begin{figure}[ht!]
%\centering
%\includegraphics[width=1\textwidth]{Cap1/cupimconcreto}
%\caption{Exemplo real de cupim frente ao seu dilema.}
%\label{FDII}
%\end{figure}

\section{Outline of this work}
\subsection{Sub-organização}
O capítulo 1 contém a introdução do trabalho, onde são expostos o objetivo, a motivação do mesmo, a descrição do sistema e a formulação do problema com a nomenclatura utilizada; além de uma revisão bibliográfica da literatura relacionada ao tema do trabalho.

\subsubsection{SubSub-organização}

No capítulo 2 apresentamos a modelagem dinâmica de um manipulador subatuado e o conceito de índice de acoplamento para medir o acoplamento dinâmico entre as juntas ativas e passivas. Este índice é utilizado para a análise e projeto de uma metodologia de controle subótimo do manipulador.

\subsubsection{Outra subsub-organizacao}

O capítulo 3 apresenta o controle subótimo de manipuladores através de redundância de atuação. Descreve-se a técnica de controle ponto a ponto de manipuladores subatuados. A seguir mostramos  a linearização destes por realimentação, cujo efeito é linearizar e desacoplar o sistema não linear. Finalmente é proposta uma sequência de controle subótimo local das juntas passivas visando a minimização de certos critérios como torque, velocidade e em particular a energia consumida pelo sistema. Este é de fato o tema principal deste mestrado.

É também apresentado no capítulo 4 um resumo do projeto de controladores  $H_{2}$ e $H_{\infty}$, cuja principal vantagem é a robustez na presença de incertezas paramétricas e distúrbios externos.

O capítulo 5 mostra as características e a operação do robô e do ambiente de simulação utilizados nos testes e experimentação da metodologia apresentada.

Os procedimentos da metodologia e os resultados obtidos para algumas configurações e diferentes controladores encontram-se no capítulo 6.

No capítulo 7 são apresentadas as conclusões do trabalho.

Quatro apêndices fazem parte do trabalho. O apêndice A apresenta alguns tópicos de álgebra linear que são a base do método proposto. No apêndice B são mostradas as equações da matriz de inércia e do vetor de torques não-inerciais
utilizados na modelagem dinâmica do manipulador. No apêndice C temos as expressões literais dessas equações feitas no software MAPLE e no apêndice D alguns programas feitos no software MATLAB utilizados no projeto \cite{Furmento1995}\cite{Morgado2003}.

